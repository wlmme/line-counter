# Line Counter 项目架构文档

## 项目概述

Line Counter 是一个使用 Rust 编写的命令行工具，用于统计文件的行数并提供详细的分析信息。该项目展示了 Rust 错误处理的最佳实践，使用 `thiserror` 和 `anyhow` 提供优雅的错误处理机制。

## 项目结构

```
line-counter/
├── Cargo.toml                 # 项目配置和依赖管理
├── Cargo.lock                 # 依赖版本锁定
├── README.md                  # 项目说明文档
├── ARCHITECTURE.md            # 架构文档（本文件）
├── .gitignore                 # Git 忽略文件配置
├── test_errors.sh             # 错误处理测试脚本
├── src/
│   └── main.rs                # 主程序源代码
├── tests/
│   └── integration_tests.rs   # 集成测试
├── benches/
│   └── benchmark.rs           # 基准测试
├── target/                    # 编译输出目录
└── 测试文件/
    ├── test_file.txt          # 基础测试文件
    └── complex_example.txt    # 复杂示例文件
```

## 代码架构

### 1. 主要组件

#### 1.1 错误处理系统

```rust
#[derive(Error, Debug)]
pub enum LineCounterError {
    // 8种具体错误类型
    InvalidPath { path: String },
    FileNotFound { path: String },
    FileReadError { path: String },
    IsDirectory { path: String },
    PermissionDenied { path: String },
    FileTooLarge { path: String, size: u64 },
    MissingArgument,
    IoError(#[from] std::io::Error),
}
```

**特点：**
- 使用 `thiserror` 派生宏自动实现错误特征
- 结构化错误信息，包含相关上下文
- 支持错误链和自动转换
- 中文错误消息，用户友好

#### 1.2 统计数据结构

```rust
#[derive(Debug, Clone)]
struct LineStats {
    total_lines: usize,
    non_empty_lines: usize,
    empty_lines: usize,
}
```

**功能：**
- 封装行数统计结果
- 提供空行占比计算
- 支持调试和克隆

#### 1.3 核心功能模块

```rust
// 主要功能函数
fn main() -> Result<()>                    // 程序入口点
fn validate_file_exists() -> Result<()>    // 文件存在性验证
fn validate_not_directory() -> Result<()>  // 目录检查
fn validate_file_size() -> Result<Metadata> // 文件大小验证
fn open_file_with_error_handling() -> Result<File> // 安全文件打开
fn count_lines() -> Result<LineStats>      // 行数统计
fn print_analysis_results()               // 结果输出
```

### 2. 设计模式

#### 2.1 错误处理模式

- **分层错误处理**：自定义错误类型 + anyhow 上下文
- **早期返回**：使用 `?` 操作符进行错误传播
- **上下文增强**：使用 `Context` trait 添加错误信息

#### 2.2 模块化设计

- **单一职责**：每个函数只负责一个特定功能
- **纯函数**：统计函数无副作用，易于测试
- **依赖注入**：通过参数传递依赖，提高可测试性

#### 2.3 资源管理

- **RAII**：文件句柄自动管理
- **缓冲 I/O**：使用 `BufReader` 提高性能
- **内存限制**：文件大小检查防止内存溢出

## 性能特征

### 1. 时间复杂度

- **文件读取**：O(n)，其中 n 是文件大小
- **行数统计**：O(m)，其中 m 是行数
- **内存占用**：O(1)，恒定缓冲区大小

### 2. 空间复杂度

- **缓冲区**：默认 8KB 缓冲区
- **统计数据**：O(1)，固定大小结构
- **错误信息**：O(k)，其中 k 是错误消息长度

### 3. 性能优化

- **缓冲读取**：减少系统调用次数
- **逐行处理**：避免将整个文件加载到内存
- **预检查**：提前验证文件属性，避免无效操作

## 测试策略

### 1. 测试层次

```
测试金字塔
    ┌─────────────────┐
    │   集成测试       │  ← 端到端功能测试
    │  (15 个测试)     │
    ├─────────────────┤
    │   单元测试       │  ← 组件功能测试
    │  (9 个测试)      │
    ├─────────────────┤
    │   基准测试       │  ← 性能测试
    │  (7 个基准)      │
    └─────────────────┘
```

### 2. 测试覆盖

#### 2.1 单元测试（src/main.rs）

- 错误类型显示格式
- `LineStats` 结构体功能
- 错误消息准确性
- 边界条件处理

#### 2.2 集成测试（tests/integration_tests.rs）

- 基本文件处理
- 空文件和空行处理
- Unicode 和特殊字符
- 大文件处理
- 错误场景测试
- 二进制文件处理

#### 2.3 基准测试（benches/benchmark.rs）

- 不同文件大小性能
- 长行文件处理
- Unicode 内容处理
- 缓冲区大小影响

### 3. 测试工具

- **Shell 脚本**：`test_errors.sh` 用于错误处理验证
- **Criterion**：性能基准测试
- **Tempfile**：临时文件管理

## 依赖管理

### 1. 核心依赖

```toml
[dependencies]
anyhow = "1.0.98"      # 错误传播和上下文
thiserror = "2.0.12"   # 自定义错误类型
```

### 2. 开发依赖

```toml
[dev-dependencies]
tempfile = "3.8"       # 测试用临时文件
criterion = "0.5"      # 基准测试框架
```

### 3. 依赖选择原则

- **最小化依赖**：只使用必要的 crate
- **稳定版本**：选择经过验证的稳定版本
- **社区认可**：使用广泛采用的标准库

## 安全考虑

### 1. 输入验证

- 文件路径验证
- 文件大小限制（100MB）
- 文件类型检查（非目录）
- 权限验证

### 2. 错误处理

- 不暴露系统内部信息
- 提供有用但安全的错误消息
- 优雅降级处理

### 3. 资源保护

- 防止内存溢出
- 限制文件大小
- 自动资源清理

## 扩展性设计

### 1. 功能扩展点

- **统计指标**：可添加更多统计维度
- **输出格式**：支持 JSON、CSV 等格式
- **文件过滤**：支持文件类型过滤
- **并行处理**：支持多文件同时处理

### 2. 配置系统

- **文件大小限制**：通过常量配置
- **缓冲区大小**：可调整 I/O 缓冲区
- **错误消息**：支持多语言本地化

### 3. 插件架构

- **统计算法**：可插拔的统计方法
- **输出格式**：可扩展的输出格式
- **文件解析**：支持不同编码格式

## 最佳实践

### 1. Rust 最佳实践

- **错误处理**：使用 `Result` 类型和 `?` 操作符
- **内存管理**：利用 RAII 和所有权系统
- **性能优化**：使用零成本抽象和缓冲 I/O

### 2. 代码质量

- **文档注释**：详细的 API 文档
- **类型安全**：强类型系统避免运行时错误
- **测试驱动**：全面的测试覆盖

### 3. 用户体验

- **友好错误**：清晰的错误消息和解决建议
- **进度反馈**：处理大文件时的进度提示
- **多语言支持**：中文错误消息

## 维护指南

### 1. 版本管理

- **语义化版本**：遵循 SemVer 规范
- **变更日志**：详细记录每次变更
- **向后兼容**：保持 API 兼容性

### 2. 质量保证

- **持续集成**：自动化测试和构建
- **代码审查**：多人审查代码变更
- **性能监控**：跟踪性能指标变化

### 3. 文档维护

- **代码文档**：保持文档与代码同步
- **示例更新**：及时更新使用示例
- **架构文档**：定期更新架构说明